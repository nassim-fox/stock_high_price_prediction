# -*- coding: utf-8 -*-
"""stock_price1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OQz9C0DKxSnGDaZ947uaFJREHUC1IiOu
"""

import pandas as p
import numpy as ny
from matplotlib import pyplot as pl

from sklearn.preprocessing import MinMaxScaler

from flask import Flask as f
from flask import request, redirect , url_for , render_template 


from flask.json import jsonify


app = f(__name__)





data = p.read_csv("all_stocks_5yr.csv")

data = p.DataFrame.dropna(data)
p.isnull(data).sum() > 0

ns = data.shape[0]
cols = data.shape[1]


data = data.drop(['date'],1)
data = data.drop(['Name'],1)

data = data[['high','open','low','close']]

data_vals = data.values

pl.plot(data)

print(data)

training_start = 0
training_end = int(ny.floor(0.01*ns)) #int(ny.floor(0.8*ns))
testing_start = training_end
testing_end = int(ny.floor(0.012*ns)) #ns


training_data = data_vals[ny.arange(training_start,training_end),:]
testing_data = data_vals[ny.arange(testing_start,testing_end),:]

print(data_vals.dtype)
print(training_data)

x_scaler = MinMaxScaler(feature_range=(0,1))
y_scaler = MinMaxScaler(feature_range=(0,1))

x_train = x_scaler.fit_transform(training_data[:,1:])
y_train = y_scaler.fit_transform(training_data[:,0].reshape(training_data[:,0].shape[0],1))

x_test = x_scaler.transform(testing_data[:,1:])
y_test = y_scaler.transform(testing_data[:,0].reshape(testing_data[:,0].shape[0],1))



print(y_train)


class NeuralNetwork() : 

    def sigmoid(self,x,drv=False) : 

        if drv == True : 
          return x * (1-x)
        else : 
          return 1 / (1+ny.exp(-x))


    ny.random.seed(1)

    def __init__(self) : 

            self.w1 = 2*ny.random.random((4,10))-1
            self.w2 = 2*ny.random.random((10,20))-1
            self.w3 = 2*ny.random.random((20,10))-1
            self.w4 = 2*ny.random.random((10,1))-1

            self.w1 = 2*ny.random.random((3,4)) - 1 
            self.w2 = 2*ny.random.random((4,4)) - 1 
            self.w21 = 2*ny.random.random((4,4)) - 1 
            self.w22 = 2*ny.random.random((4,4)) - 1 
            self.w23 = 2*ny.random.random((4,4)) - 1 
            self.w3 = 2*ny.random.random((4,1)) - 1 

            self.b1 = ny.zeros((1,4)) 
            self.b2 = ny.zeros((1,4)) 
            self.b21 = ny.zeros((1,4)) 
            self.b22 = ny.zeros((1,4)) 
            self.b23 = ny.zeros((1,4))
            self.b3 = ny.zeros((1,1))  
            
            l0 = l1 = l2 = l3 = l21 = l22 = l23 = ss = 0 
            
            self.e = 30000
            
            self.learning_rate = 0.01 
            
            
            

    def forward_propagation(self) : 

        self.l0 = x_train 
        self.l1 = self.sigmoid(ny.dot(self.l0,self.w1)+self.b1)
        self.l2 = self.sigmoid(ny.dot(self.l1,self.w2)+self.b2)
        self.l21 = self.sigmoid(ny.dot(self.l2,self.w21)+self.b21)
        self.l22 = self.sigmoid(ny.dot(self.l21,self.w22)+self.b22)
        self.l23 = self.sigmoid(ny.dot(self.l22,self.w23)+self.b23)
        self.ss = self.sigmoid(ny.dot(self.l22,self.w3)+self.b3)

        return self.ss
    
    
    def backpropagation(self,ss,j) : 
        

        err =  y_train - ss 

        if ( j % 1000 ) == 1 : 
            print(ny.mean(ny.abs(err)))

        ss_delta = err * self.sigmoid(ss,True) 

        l2_err = ss_delta.dot(self.w3.T)

        l2_delta = l2_err * self.sigmoid(self.l2,True)

        l21_err = l2_delta.dot(self.w2.T)

        l21_delta = l21_err * self.sigmoid(self.l21,True)

        l22_err = l21_delta.dot(self.w21.T)

        l22_delta = l2_err * self.sigmoid(self.l22,True)

        l23_err = l22_delta.dot(self.w22.T)

        l23_delta = l2_err * self.sigmoid(self.l23,True)

        l1_err = l23_delta.dot(self.w23.T)

        l1_delta = l1_err * self.sigmoid(self.l1,True)
 

        self.w3 += self.learning_rate*self.l22.T.dot(ss_delta)
        self.w22 += self.learning_rate*self.l21.T.dot(l22_delta)
        self.w21 += self.learning_rate*self.l2.T.dot(l21_delta)
        self.w2 += self.learning_rate*self.l1.T.dot(l2_delta)
        self.w1 += self.learning_rate*self.l0.T.dot(l1_delta)

        self.b3 = self.b3 + ny.multiply(self.learning_rate,ss_delta)
        self.b22 = self.b3 + ny.multiply(self.learning_rate,self.learning_rate*l22_delta)
        self.b21 = self.b3 + ny.multiply(self.learning_rate,self.learning_rate*l21_delta)
        self.b2 = self.b3 + ny.multiply(self.learning_rate,self.learning_rate*l2_delta)
        self.b1 = self.b3 + ny.multiply(self.learning_rate,self.learning_rate*l1_delta)



    def session(self) : 

        for j in range(self.e) : 


            self.ss = self.forward_propagation()

            self.backpropagation(self.ss,j) 


        print(y_scaler.inverse_transform(self.ss)[0])
        print(y_scaler.inverse_transform(y_train)[0])
        print(x_train[0])
        print(y_train[0])
        print(self.ss[0])


       # fig = pl.figure()
        #ax = pl.axes()
        #ax.plot(y_scaler.inverse_transform(y_train))
        #ax.plot(y_scaler.inverse_transform(self.ss))
       
    
    
    
    def predict(self) : 
        self.ss = self.forward_propagation() 
        
        
    def get_result(self) : 
            
        r = y_scaler.inverse_transform(self.ss).T[0]
        #ny.array2string(y_scaler.inverse_transform(self.ss).T[0])
                            
        rs = '{ ' 
                            
        for i in range(r.size) : 
                rs = rs + ' "{}" : "{}" , '.format(i,r[i])
                            
        rs = rs + '}'
        return rs#jsonify(,precision=2,separator=',',suppress_small=True))
    
    
    def update(self,e,learning_rate) : 
         self.e = e
         self.learning_rate = learning_rate
            
            
nn = NeuralNetwork()
    
@app.route('/stock_prices',methods=['GET','POST']) 
def sp() : 
    
    nn.session()
    #return render_template('stock_price.html',result=nn.ss)
    return nn.get_result()

@app.route('/stock_prices_data',methods=['GET']) 
def spd() : 
    r = y_scaler.inverse_transform(y_train).T[0]
    rs = '{ ' 
                            
    for i in range(r.size) : 
            rs = rs + ' "{}" : "{}" , '.format(i,r[i])
                      
    rs = rs + '}'
    
    print(y_scaler.inverse_transform(y_train).T[0][0])
    
    return rs
    #return render_template('stock_price.html',result=nn.ss)


@app.route('/stock_prices_predict',methods=['GET','POST']) 
def predict() : 
    nn.predict()
    #return render_template('stock_price.html',result=nn.ss)
    return nn.get_result()

@app.route('/update',methods=['GET','POST']) 
def update() : 
    if request.method=="POST"  : 
        e = int(request.form["epochs"]) 
        learning_rate = float(request.form["learning_rate"])
        nn.update(e,learning_rate)
        #return render_template('stock_price.html',result=nn.ss)
        return '1'


@app.route('/index',methods=['GET']) 
def index() : 
    nn = NeuralNetwork()
    nn.update(30000,0.01)
    return render_template('stock_price.html') 


if __name__ == "__main__" :  
    app.run(debug=True)    
